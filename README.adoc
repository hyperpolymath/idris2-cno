// SPDX-License-Identifier: PMPL-1.0-or-later
= idris2-cno

image:https://img.shields.io/badge/License-PMPL--1.0-blue.svg[License: PMPL-1.0,link="https://github.com/hyperpolymath/palimpsest-license"]
image:https://img.shields.io/badge/Philosophy-Palimpsest-indigo.svg[Palimpsest,link="https://github.com/hyperpolymath/palimpsest-license"]
image:https://img.shields.io/badge/Idris2-0.6+-blue.svg[Idris2]
image:https://img.shields.io/badge/Status-v0.1.0-green.svg[Status]

**Certified Null Operations in Idris2 Dependent Types**

A CNO is an operation that provably has no effect - the identity transformation encoded as a type with proof obligations. This library brings the https://github.com/hyperpolymath/absolute-zero[absolute-zero] formal verification concepts to Idris2's dependent type system.

== The Key Insight

A Certified Null Operation (CNO) bundles:

1. A function `f : a -> a`
2. A proof that `∀x. f(x) = x`

[source,idris]
----
data CNO : Type -> Type where
  MkCNO : (f : a -> a) -> (prf : (x : a) -> f x = x) -> CNO a
----

If you can construct a `CNO a`, you have **compile-time proof** that the operation is identity.

== Quick Start

[source,idris]
----
import CNO

-- The trivial CNO (literally id with Refl)
noop : CNO Integer
noop = trivial

-- A "complex" CNO that adds zero
addZero : CNO Integer
addZero = MkCNO (\x => x + 0) (\x => plusZeroProof x)

-- Compose CNOs (result is also identity)
composed : CNO Integer
composed = noop . addZero

-- Apply (always returns the same value)
result : Integer
result = apply noop 42  -- Returns 42, proven at compile time
----

== Installation

=== Using Pack (Recommended)

The easiest way to install is using https://github.com/stefan-hoeck/idris2-pack[pack]:

[source,bash]
----
# Install from local clone
git clone https://github.com/hyperpolymath/idris2-cno.git
cd idris2-cno
pack install idris2-cno
----

Or add to your project's `pack.toml`:

[source,toml]
----
[custom.all.idris2-cno]
type   = "github"
url    = "https://github.com/hyperpolymath/idris2-cno"
commit = "main"
ipkg   = "idris2-cno.ipkg"
----

=== Manual Installation

[source,bash]
----
# Clone the repository
git clone https://github.com/hyperpolymath/idris2-cno.git
cd idris2-cno

# Build and install
idris2 --install idris2-cno.ipkg

# Or install to custom location
IDRIS2_PREFIX=/path/to/install idris2 --install idris2-cno.ipkg
----

=== Dependencies

* Idris2 >= 0.6.0
* `base`, `contrib` packages (included with Idris2)

== API Reference

=== Creating CNOs

[source,idris]
----
import CNO
import CNO.Core
import CNO.Proof

-- Trivial CNO (recommended for most cases)
noop : CNO a
noop = idCNO

-- Custom CNO with manual proof
myIdentity : CNO Integer
myIdentity = MkCNO (\x => x) (\x => Refl)

-- CNO from a function that you prove is identity
fromProof : (f : a -> a) -> ((x : a) -> f x = x) -> CNO a
fromProof f prf = MkCNO f prf
----

=== Running CNOs

[source,idris]
----
import CNO.Core

-- Apply a CNO (guaranteed to return input)
result : Integer
result = runCNO idCNO 42  -- Returns 42

-- Get the proof
proof : (x : Integer) -> runCNO idCNO x = x
proof x = cnoProof idCNO x
----

=== Composing CNOs

[source,idris]
----
import CNO.Composition

-- Sequential composition (>>>)
c1 : CNO Integer
c1 = idCNO >>> idCNO  -- Still identity

-- Parallel on pairs (***)
c2 : CNO (Integer, String)
c2 = idCNO *** idCNO

-- Sum on Either (+++)
c3 : CNO (Either Integer String)
c3 = idCNO +++ idCNO

-- N-ary composition
c4 : CNO Integer
c4 = composeN 10 idCNO  -- 10x identity = identity
----

=== Verified CNOs

[source,idris]
----
import CNO.Verified

-- Named CNO for debugging
named : VerifiedCNO Integer
named = verified "step1" idCNO

-- Chain of CNOs
chain : CNOChain 3 Integer
chain = noop "a" :: noop "b" :: noop "c" :: Nil

-- Run chain (proven to be identity)
runMyChain : Integer -> Integer
runMyChain = runChain chain
----

== Why CNOs?

CNOs are useful for:

[cols="1,2"]
|===
|Use Case |Description

|**Middleware placeholders**
|Type-safe no-ops in middleware chains

|**Disabled features**
|Features that compile to nothing when disabled

|**Reversible operations**
|Operations that are their own inverse

|**Proof of no side effects**
|Guarantee a transformation preserves values

|**Testing**
|Verify that "do nothing" actually does nothing
|===

== Composition

CNOs compose while preserving the identity property:

[source,idris]
----
-- Sequential composition
c1 >>> c2 : CNO a

-- Backward composition
c1 <<< c2 : CNO a

-- Parallel composition on pairs
c1 *** c2 : CNO (a, b)

-- Sum composition on Either
c1 +++ c2 : CNO (Either a b)

-- N-ary composition
composeAll : List (CNO a) -> CNO a
composeN : Nat -> CNO a -> CNO a  -- Apply n times (still identity!)
----

== Categorical Structure

CNOs form a trivial category where every morphism is the identity:

[source,idris]
----
-- All CNOs are isomorphisms (they're their own inverse)
inverse : CNO a -> CNO a
inverse cno = cno  -- A CNO is its own inverse!

-- Category laws hold trivially
leftIdentity : id . f = f  ✓
rightIdentity : f . id = f  ✓
associativity : (f . g) . h = f . (g . h)  ✓
----

== Ecosystem Integration

idris2-cno is part of the hyperpolymath Idris2 verification stack:

[source]
----
┌─────────────────────────────────────────────────────────────┐
│                    Your Application                          │
└─────────────────────────────────────────────────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
    ┌─────────┐           ┌─────────────┐         ┌─────────┐
    │idris2-  │           │ idris2-     │         │idris2-  │
    │ dyadt   │──────────►│ echidna     │◄────────│  cno    │
    │(claims) │           │ (provers)   │         │(CNOs)   │
    └─────────┘           └─────────────┘         └─────────┘
----

=== With idris2-dyadt (Claims)

[source,idris]
----
import CNO
import CNO.Integration.Dyadt

-- Express CNO properties as dyadt claims
cnoClaim : CNODyadtClaim
cnoClaim = CNOIsValid "myTransform"

-- Verify and get a dyadt-verified CNO
verified : DyadtVerifiedCNO Integer
verified = dyadtVerify "addZero" addZero

-- Run with verification
result : Integer
result = runDyadtVerified verified 42
----

=== With idris2-echidna (Theorem Proving)

[source,idris]
----
import CNO
import CNO.Integration.Echidna

-- Generate a theorem for proving CNO property
thm : CNOTheorem
thm = identityTheorem "myFunc" "Int"

-- Create proof obligation
obligation : ProofObligation
obligation = ProveIdentity "transform" "Int"

-- Proof-carrying CNO with external proof reference
proven : ProofCarryingCNO Integer
proven = withExternalProof idCNO "z3_proof_hash" "Z3" [obligation]
----

== Example CNOs

[source,idris]
----
import CNO.Examples

-- Numeric CNOs
addZero : CNO Integer      -- x + 0 = x
multiplyOne : CNO Integer  -- x * 1 = x

-- List CNOs
appendNil : CNO (List a)      -- xs ++ [] = xs
reverseReverse : CNO (List a) -- reverse (reverse xs) = xs

-- Maybe CNOs
mapIdMaybe : CNO (Maybe a)  -- map id = id

-- Pair CNOs
swapSwap : CNO (a, b)  -- swap (swap p) = p
----

== VerifiedCNO and CNOChain

[source,idris]
----
import CNO.Verified

-- Verified CNO with name
vcno : VerifiedCNO Integer
vcno = verified "step1" idCNO

-- Chain of verified CNOs
chain : CNOChain 3 Integer
chain = noop "a" :: noop "b" :: noop "c" :: Nil

-- Run chain (still identity!)
runChain chain x = x  -- Proven!
----

== Related Projects

* https://github.com/hyperpolymath/absolute-zero[absolute-zero] - Formal CNO proofs in Coq, Lean 4, Agda, Isabelle, Mizar
* https://github.com/hyperpolymath/aletheia[aletheia] - Reversible operations research
* https://github.com/hyperpolymath/idris2-dyadt[idris2-dyadt] - Compile-time verified claims
* https://github.com/hyperpolymath/idris2-echidna[idris2-echidna] - ECHIDNA theorem prover bindings
* https://github.com/hyperpolymath/did-you-actually-do-that[did-you-actually-do-that] - Runtime verification (Rust)

== License

MPL-2.0. See link:LICENSE[LICENSE] for details.
